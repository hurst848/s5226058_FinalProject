// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "noiseSimplex.cginc"

struct vec3
{
    float x;
    float y;
    float z;
};

int WindMapResolution;
int NumberOfWindIterations;
float DeviationMax;
int itr;
RWStructuredBuffer<vec3> WindMap;

float3 toFloat3(vec3 _inp)
{
    return float3(_inp.x, _inp.y, _inp.z);
}

vec3 toVec3(float3 _inp)
{
    vec3 rtrn;
    rtrn.x = _inp.x;
    rtrn.y = _inp.y;
    rtrn.z = _inp.z;
    return rtrn;
}

vec3 addVec3(vec3 _a, vec3 _b)
{
    vec3 rtrn;
    rtrn.x = _a.x + _b.x;
    rtrn.y = _a.y + _b.y;
    rtrn.z = _a.z + _b.z;
    return rtrn;
}

float mapValues(float _value, float _fromA, float _ToA, float _fromB, float _ToB)
{
    return (_value - _fromA) / (_ToA - _fromA) * (_ToB - _fromB) + _fromB;
}

int GetCoordinate(int _x, int _y)
{
    return _x + (_y * (WindMapResolution * 3));
}

vec3 AddDeviation(vec3 _inp)
{
    itr++;
    vec3 rtrn;
    int attribute = mapValues(snoise(toFloat3(_inp) * itr), 0, 1, 0 , 3);
    if (attribute < 1)
    {   
        rtrn = toVec3(float3(_inp.x + mapValues(snoise(toFloat3(_inp) * 12 * itr), 0, 1, -DeviationMax , DeviationMax), _inp.y, _inp.z));
    }
    else if (attribute < 2)
    {
        rtrn = toVec3(float3(_inp.x, _inp.y + mapValues(snoise(toFloat3(_inp) * 123 * itr), 0, 1, -DeviationMax , DeviationMax), _inp.z));
    }
    else
    {
        rtrn = toVec3(float3(_inp.x, _inp.y, _inp.z + mapValues(snoise(toFloat3(_inp) * 4783 * itr), 0, 1, -DeviationMax , DeviationMax)));
    }
    return rtrn;

}

bool IsWithinMap(int _x, int _y)
{
    
    if (_x < WindMapResolution && _y < WindMapResolution) { return false; }
    if (_x > WindMapResolution * 2 && _y < WindMapResolution) { return false; }
    if (_x < WindMapResolution && _y > WindMapResolution * 2) { return false; }
    if (_x > WindMapResolution * 2 && _y > WindMapResolution * 2) { return false; }
    
    return true;

}

bool IsNotOnEdge(int _x, int _y)
{
    if (_y == 0) { return false; }
    if (_x == WindMapResolution - 1 && _y < WindMapResolution) { return false; }
    if (_x == (WindMapResolution * 2) - 1 && _y < WindMapResolution) { return false; }
    if ((_x < WindMapResolution || _x > 2 * WindMapResolution) && _y == WindMapResolution) { return false; }
    if (_x == 0 || _x == 3 * WindMapResolution -1) { return false; }
    if (_x == WindMapResolution - 1 && _y > 2 * WindMapResolution) { return false; }
    if (_x == 2 * WindMapResolution - 1 && _y > 2 * WindMapResolution) { return false; }
    if (_y == 4 * WindMapResolution - 1) { return false; }
    return true;

}

bool IsZero(vec3 _inp)
{
    if (_inp.x == 0 && _inp.y == 0 && _inp.z == 0) {return true;}
    return false;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    itr = 0;
    float XRes = WindMapResolution * 3;
    float YRes = WindMapResolution * 4;
    for (int i = 0; i < NumberOfWindIterations; i++)
    {
        for (int x = 0; x < XRes; x++)
        {
            for (int y = 0; y < YRes; y++)
            {
                
                if (x <= WindMapResolution)
                {
                    vec3 rtrn;
                    rtrn.x = 1;
                    rtrn.y = 0;
                    rtrn.z = 0;
                    WindMap[GetCoordinate(x,y)] = rtrn;
                }
                else
                {
                    vec3 rtrn;
                    rtrn.x = 0;
                    rtrn.y = 1;
                    rtrn.z = 0;
                    WindMap[GetCoordinate(x,y)] = rtrn;
                }

                // if (IsWithinMap(x,y))
                // {
                //     vec3 rtrn;
                //     rtrn.x = 1;
                //     rtrn.y = 0;
                //     rtrn.z = 0;
                //     WindMap[GetCoordinate(x,y)] = rtrn;
                // }
                // else
                // {
                //     vec3 rtrn;
                //     rtrn.x = 0;
                //     rtrn.y = 1;
                //     rtrn.z = 0;
                //     WindMap[GetCoordinate(x,y)] = rtrn;
                // }

                // // if (IsWithinMap(x,y) && IsNotOnEdge(x,y))
                // // {
                // //     if (!IsZero(WindMap[GetCoordinate(x,y)]))
                // //     {
                        
                // //     }
                // //     else 
                // //     {
                // //         vec3 tmp;
                // //         tmp.x = 1;
                // //         tmp.y = 1;
                // //         tmp.z = 1;
                // //         WindMap[GetCoordinate(x,y)] = tmp;
                // //     }
                    
                // // }
                
            }
        }
    }    
}

// itr++;
//                 vec3 CurrentSample = WindMap[GetCoordinate(x,y)];
//                 vec3 a = addVec3(WindMap[GetCoordinate(x - 1, y + 1)], AddDeviation(CurrentSample));
//                         WindMap[GetCoordinate(x - 1, y + 1)] = a;

//                         vec3 b = addVec3(WindMap[GetCoordinate(x    , y + 1)], AddDeviation(CurrentSample));
//                         WindMap[GetCoordinate(x    , y + 1)] = b;
                        
//                         vec3 c = addVec3(WindMap[GetCoordinate(x + 1, y + 1)], AddDeviation(CurrentSample));
//                         WindMap[GetCoordinate(x + 1, y + 1)] = c;

//                         vec3 d = addVec3(WindMap[GetCoordinate(x - 1, y    )], AddDeviation(CurrentSample));
//                         WindMap[GetCoordinate(x - 1, y    )] = d;
                        
//                         vec3 e = addVec3(WindMap[GetCoordinate(x + 1, y    )], AddDeviation(CurrentSample));
//                         WindMap[GetCoordinate(x + 1, y    )] = e;

//                         vec3 f = addVec3(WindMap[GetCoordinate(x - 1, y - 1)], AddDeviation(CurrentSample));
//                         WindMap[GetCoordinate(x - 1, y - 1)] = f;

//                         vec3 g = addVec3(WindMap[GetCoordinate(x    , y - 1)], AddDeviation(CurrentSample));
//                         WindMap[GetCoordinate(x    , y - 1)] = g;

//                         vec3 h = addVec3(WindMap[GetCoordinate(x + 1, y - 1)], AddDeviation(CurrentSample));
//                         WindMap[GetCoordinate(x + 1, y - 1)] = h;