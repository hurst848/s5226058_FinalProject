#pragma kernel CSMain


// https://gist.github.com/fadookie/25adf86ae7e2753d717c
#include "noiseSimplex.cginc"

struct VertexData
{
    float3 Location;
    float temperature;

};

struct PlanetData
{
    float radius;
    int resolution;
    int numNormals;
};

struct vec3
{
    float x;
    float y;
    float z;
};

float mapValues(float _value, float _fromA, float _ToA, float _fromB, float _ToB)
{
    return (_value - _fromA) / (_ToA - _fromA) * (_ToB - _fromB) + _fromB;
}

// LOD SHOULD MAP BETWEEN 25 and 255 res

RWStructuredBuffer<PlanetData> Data;
RWStructuredBuffer<vec3> Normals;
RWStructuredBuffer<float3> Verticies;
RWStructuredBuffer<int> Triangles;


float3 cameraPosition;
float3 planetPosition;
float maximumTerrainHeight;
int LevelOfDetail;


//! Base Noise Parameter
float Base_NoiseScale;
float3 Base_Offset;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    //! Set the poles
    float3 NorthPole = float3(0,1,0)  * Data[0].radius;
    float3 SouthPole = float3(0,-1,0) * Data[0].radius;
    float3 EquatorPole = float3(1,0,0) * Data[0].radius;
    float MaximumDistance = 0.0;
    MaximumDistance = abs(length(NorthPole - EquatorPole));

    //! Set required itr values
    int numVerts = 0;
    int vertIndex = 0;
    int numTris = 0;
    for (int i = 0; i < Data[0].numNormals; i++)
    {
        float3 normal = float3(Normals[i].x, Normals[i].y, Normals[i].z);
        float3 AxisA = float3(normal.y, normal.z, normal.x);
        float3 AxisB = cross(normal, AxisA);

        
        for (int y = 0; y < Data[0].resolution; y++)
        {
            for (int x = 0; x < Data[0].resolution; x++)
            {
                int itr = (x + (y * Data[0].resolution)) + numVerts;
                
                float2 percent = float2(y,x) / (Data[0].resolution - 1);

                float3 pointOnUnitCube = normal + (percent.x - 0.5f) * 2 * AxisA + (percent.y - 0.5f) * 2 * AxisB;
                float3 pointOnUnitSphere = normalize(pointOnUnitCube);
                
                // Apply initial noise values
                float3 First_TerrainVertex = pointOnUnitSphere * mapValues(snoise(pointOnUnitSphere * Base_NoiseScale + Base_Offset), 0.0, 1.0, Data[0].radius, Data[0].radius + maximumTerrainHeight);

                //! Calculate Temperature !//
                    //! Calculate the Distance to the nearest pole
                float3 pointOnGround = pointOnUnitSphere * Data[0].radius;
                float DistanceToNorthPole = abs(length(NorthPole - pointOnGround));
                float DistanceToSouthPole = abs(length(SouthPole - pointOnGround));
                float DistanceToPole = 0.0;
                if (DistanceToNorthPole <= MaximumDistance){ DistanceToPole = DistanceToNorthPole; }
                else { DistanceToPole = DistanceToSouthPole; }
                DistanceToPole = mapValues(DistanceToPole, 0.0, MaximumDistance, 0.0, 1.75);
                    //! Calculate the Height value
                float HeightFromGround = mapValues(length(First_TerrainVertex) - Data[0].radius, 0.0, maximumTerrainHeight, 0.0, 0.25 );
                    //! Combine values and map to a 0.0 to 1.0 value
                float TemperatureAtVertex = mapValues(DistanceToPole + HeightFromGround, 0.0, 2.0, 0.0, 1.0);
                
                

                //! Set Vertex in Array
                Verticies[vertIndex] = First_TerrainVertex;
                vertIndex++;
                

                if (x < Data[0].resolution -1)
                {
                    if (y < Data[0].resolution -1)
                    {
                        Triangles[numTris] = itr;
                        Triangles[numTris + 1] = itr + Data[0].resolution;
                        Triangles[numTris + 2] = itr + Data[0].resolution + 1;
                        Triangles[numTris + 3] = itr;
                        Triangles[numTris + 4] = itr + Data[0].resolution + 1;
                        Triangles[numTris + 5] = itr + 1;
                        numTris+=6;
                    }
                }
            }   
        }
        numVerts+= Data[0].resolution * Data[0].resolution;
    }


        
}
