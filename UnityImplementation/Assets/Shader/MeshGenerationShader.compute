// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct PlanetData
{
    float radius;
    int resolution;
    int numNormals;
};


RWStructuredBuffer<PlanetData> Data;
RWStructuredBuffer<float4> Normals;
RWStructuredBuffer<float4> Verticies;
RWStructuredBuffer<int> Triangles;



[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!
    for (int i = 0; i < Data[0].numNormals; i++)
    {
        float3 AxisA = float3(Normals[i].y,Normals[i].z ,Normals[i].x);
        float3 AxisB = cross(Normals[i], AxisA);

        int numVerts = 0;
        int vertIndex = 0;
        int numTris = 0;
        for (int y = 0; y < Data[0].resolution; y++)
        {
            for (int x = 0; x < Data[0].resolution; x++)
            {
                int itr = (x + (y * Data[0].resolution)) + numVerts;
                
                float2 percent = float2(y,x) / (Data[0].resolution - 1);

                float3 pointOnUnitCube = Normals[i] + (percent.x - 0.5f) * 2 * AxisA + (percent.y - 0.5f) * 2 * AxisB;
                float3 pointOnUnitSphere = normalize(pointOnUnitCube) * Data[0].radius;

                Verticies[vertIndex] = pointOnUnitSphere;
                vertIndex++;

                if (x < Data[0].resolution -1 && y < Data[0].resolution -1)
                {
                    Triangles[numTris] = itr;
                    Triangles[numTris + 1] = itr + Data[0].resolution;
                    Triangles[numTris + 2] = itr + Data[0].resolution + 1;
                    Triangles[numTris + 3] = itr;
                    Triangles[numTris + 2] = itr + Data[0].resolution + 1;
                    Triangles[numTris + 1] = itr + Data[0].resolution;
                }
            }   
        }

    }       
        
}
