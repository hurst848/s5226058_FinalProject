#pragma kernel CSMain


// https://gist.github.com/fadookie/25adf86ae7e2753d717c
#include "noiseSimplex.cginc"


struct PlanetData
{
    float radius;
    int resolution;
    int numNormals;
};

struct vec3
{
    float x;
    float y;
    float z;
};

float mapValues(float _value, float _fromA, float _ToA, float _fromB, float _ToB)
{
    return (_value - _fromA) / (_ToA - _fromA) * (_ToB - _fromB) + _fromB;
}

// LOD SHOULD MAP BETWEEN 25 and 255 res

RWStructuredBuffer<PlanetData> Data;
RWStructuredBuffer<vec3> Normals;
RWStructuredBuffer<float3> Verticies;
RWStructuredBuffer<int> Triangles;


float3 cameraPosition;
float3 planetPosition;
float maximumTerrainHeight;
int LevelOfDetail;

//! Biome Parameters
float TemperatureWeight;
int WindResolution;

//! Base Noise Parameter
float Base_NoiseScale;
float3 Base_Offset;




[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

    // Counters
        int numVerts = 0;
        int vertIndex = 0;
        int numTris = 0;
    for (int i = 0; i < Data[0].numNormals; i++)
    {
        // Setup Basic Required 
        float3 normal = float3(Normals[i].x, Normals[i].y, Normals[i].z);
        float3 AxisA = float3(normal.y, normal.z, normal.x);
        float3 AxisB = cross(normal, AxisA);
        // Culmaive offset from edge of face 
        float3 offset = float3(0.0,0.0,0.0);
        // Cycle through all the levels of detail
        for (int j = 0; j < LevelOfDetail; j++)
        {
            // If its the last level of detail, generate the centeral square
            if (j >= LevelOfDetail - 1)
            {
                float2 SinglePercent = float2(1,1) / (Data[0].resolution * pow(2.0, j - 1) - 1.0);
                for (int y = 0; y < Data[0].resolution; y++)
                {
                    for (int x = 0; x < Data[0].resolution; x++)
                    {
                        int itr = (x + (y * Data[0].resolution)) + numVerts;
                        float2 percent = float2(y,x) / (Data[0].resolution * pow(2.0, j - 1) - 1.0);
                        

                        float3 pointOnUnitCube = normal + (percent.x - 0.5f) * 2 * AxisA + (percent.y - 0.5f) * 2 * AxisB;
                        float3 pointOnUnitSphere = normalize(pointOnUnitCube);
                        
                        // Apply initial noise values
                        float3 First_TerrainVertex = pointOnUnitSphere * mapValues(snoise(pointOnUnitSphere * Base_NoiseScale + Base_Offset), 0.0, 1.0, Data[0].radius, Data[0].radius + maximumTerrainHeight);
                        Verticies[vertIndex] = First_TerrainVertex;
                        vertIndex++;
                        

                        if (x < Data[0].resolution -1)
                        {
                            if (y < Data[0].resolution -1)
                            {
                                Triangles[numTris] = itr;
                                Triangles[numTris + 2] = itr + Data[0].resolution + 1;
                                Triangles[numTris + 1] = itr + Data[0].resolution;
                                Triangles[numTris + 3] = itr;
                                Triangles[numTris + 5] = itr + 1;
                                Triangles[numTris + 4] = itr + Data[0].resolution + 1;
                                numTris+=6;
                                        
                                numTris+=6;
                            }
                        }
                    }   
                }
                numVerts+= Data[0].resolution * Data[0].resolution;
            }
            else
            {
                
                

                for (int y = 0; y < Data[0].resolution; y++)
                {
                    for (int x = 0; x < Data[0].resolution; x++)
                    {
                        int itr = (x + (y * Data[0].resolution)) + numVerts;
                        float2 percent = float2(y,x) / (Data[0].resolution * pow(2.0, j - 1) - 1.0);
                        

                        float3 pointOnUnitCube = normal + (percent.x - 0.5f) * 2 * AxisA + (percent.y - 0.5f) * 2 * AxisB;
                        float3 pointOnUnitSphere = normalize(pointOnUnitCube);
                        
                        // Apply initial noise values
                        float3 First_TerrainVertex = pointOnUnitSphere * mapValues(snoise(pointOnUnitSphere * Base_NoiseScale + Base_Offset), 0.0, 1.0, Data[0].radius, Data[0].radius + maximumTerrainHeight);
                        Verticies[vertIndex] = First_TerrainVertex;
                        vertIndex++;
                        

                        if (x < Data[0].resolution -1)
                        {
                            if (y < Data[0].resolution -1)
                            {
                                Triangles[numTris] = itr;
                                Triangles[numTris + 2] = itr + Data[0].resolution + 1;
                                Triangles[numTris + 1] = itr + Data[0].resolution;
                                Triangles[numTris + 3] = itr;
                                Triangles[numTris + 5] = itr + 1;
                                Triangles[numTris + 4] = itr + Data[0].resolution + 1;
                                numTris+=6;
                                        
                                numTris+=6;
                            }
                        }
                                                
                    }   
                }
                float2 SinglePercent = float2(1,1) / (Data[0].resolution * pow(2.0, LevelOfDetail - 1) - 1.0);
                offset += float3(SinglePercent.x, SinglePercent.y, 0) * 2;

                numVerts+= (Data[0].resolution * 4) + (4 * (Data[0].resolution - 4));

            }
        }
    }
    //! Set required itr values
    // int numVerts = 0;
    // int vertIndex = 0;
    // int numTris = 0;
    // for (int i = 0; i < Data[0].numNormals; i++)
    // {
    //     float3 normal = float3(Normals[i].x, Normals[i].y, Normals[i].z);
    //     float3 AxisA = float3(normal.y, normal.z, normal.x);
    //     float3 AxisB = cross(normal, AxisA);

        
    //     for (int y = 0; y < Data[0].resolution; y++)
    //     {
    //         for (int x = 0; x < Data[0].resolution; x++)
    //         {
    //             int itr = (x + (y * Data[0].resolution)) + numVerts;
                
    //             float2 percent = float2(y,x) / (Data[0].resolution - 1);

    //             float3 pointOnUnitCube = normal + (percent.x - 0.5f) * 2 * AxisA + (percent.y - 0.5f) * 2 * AxisB;
    //             float3 pointOnUnitSphere = normalize(pointOnUnitCube);
                
    //             // Apply initial noise values
    //             float3 First_TerrainVertex = pointOnUnitSphere * mapValues(snoise(pointOnUnitSphere * Base_NoiseScale + Base_Offset), 0.0, 1.0, Data[0].radius, Data[0].radius + maximumTerrainHeight);
    //             //! Set Vertex in Array
    //             Verticies[vertIndex] = First_TerrainVertex;
    //             vertIndex++;
                

    //             if (x < Data[0].resolution -1)
    //             {
    //                 if (y < Data[0].resolution -1)
    //                 {
    //                     Triangles[numTris] = itr;
    //                     Triangles[numTris + 1] = itr + Data[0].resolution;
    //                     Triangles[numTris + 2] = itr + Data[0].resolution + 1;
    //                     Triangles[numTris + 3] = itr;
    //                     Triangles[numTris + 4] = itr + Data[0].resolution + 1;
    //                     Triangles[numTris + 5] = itr + 1;
    //                     numTris+=6;
    //                 }
    //             }
    //         }   
    //     }
    //     numVerts+= Data[0].resolution * Data[0].resolution;
    // }
        
}

void RenderLOD()
{
    // Counters
        int numVerts = 0;
        int vertIndex = 0;
        int numTris = 0;
    for (int i = 0; i < Data[0].numNormals; i++)
    {
        // Setup Basic Required 
        float3 normal = float3(Normals[i].x, Normals[i].y, Normals[i].z);
        float3 AxisA = float3(normal.y, normal.z, normal.x);
        float3 AxisB = cross(normal, AxisA);
        // Culmaive offset from edge of face 
        float3 offset = float3(0.0,0.0,0.0);
        // Cycle through all the levels of detail
        for (int j = 0; j < LevelOfDetail; j++)
        {
            // If its the last level of detail, generate the centeral square
            if (j >= LevelOfDetail - 1)
            {
                float2 SinglePercent = float2(1,1) / (Data[0].resolution * pow(2.0, LevelOfDetail - 1) - 1.0);
                for (int y = 0; y < Data[0].resolution; y++)
                {
                    for (int x = 0; x < Data[0].resolution; x++)
                    {
                        int itr = (x + (y * Data[0].resolution)) + numVerts;
                        float2 percent = float2(y,x) / (Data[0].resolution * pow(2.0, LevelOfDetail - 1) - 1.0);
                        

                        float3 pointOnUnitCube = normal + (percent.x - 0.5f) * 2 * AxisA + (percent.y - 0.5f) * 2 * AxisB;
                        float3 pointOnUnitSphere = normalize(pointOnUnitCube);
                        
                        // Apply initial noise values
                        float3 First_TerrainVertex = pointOnUnitSphere * mapValues(snoise(pointOnUnitSphere * Base_NoiseScale + Base_Offset), 0.0, 1.0, Data[0].radius, Data[0].radius + maximumTerrainHeight);
                        Verticies[vertIndex] = First_TerrainVertex;
                        vertIndex++;
                        

                        if (x < Data[0].resolution -1)
                        {
                            if (y < Data[0].resolution -1)
                            {
                                Triangles[numTris] = itr;
                                Triangles[numTris + 2] = itr + Data[0].resolution + 1;
                                Triangles[numTris + 1] = itr + Data[0].resolution;
                                Triangles[numTris + 3] = itr;
                                Triangles[numTris + 5] = itr + 1;
                                Triangles[numTris + 4] = itr + Data[0].resolution + 1;
                                numTris+=6;
                                        
                                numTris+=6;
                            }
                        }
                    }   
                }
                numVerts+= Data[0].resolution * Data[0].resolution;
            }
            else
            {
                float2 SinglePercent = float2(1,1) / (Data[0].resolution * pow(2.0, LevelOfDetail - 1) - 1.0);
                offset += float3(SinglePercent.x, SinglePercent.y, 0);

            }
        }
    }
}





