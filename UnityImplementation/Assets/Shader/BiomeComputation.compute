#pragma kernel CSMain

// https://gist.github.com/fadookie/25adf86ae7e2753d717c
#include "noiseSimplex.cginc"

struct SerializedBiome
{
    float MinHS;
    float MaxHS;
    float MinMS;
    float MaxMS;
    float BNS;
    float BRA;
};

RWStructuredBuffer<float> temperatureData;
RWStructuredBuffer<float> windData;
RWStructuredBuffer<int> biomeMap;
RWStructuredBuffer<SerializedBiome> biomes;

int numBiomes;
float TemperatureWeight;
int BiomeMapResolution;
float Radius;
float NoiseScale;
float3 Offset;
float MaximumTerrainHeight;

float mapValues(float _value, float _fromA, float _ToA, float _fromB, float _ToB)
{
    return (_value - _fromA) / (_ToA - _fromA) * (_ToB - _fromB) + _fromB;
}

int2 getXYCoord(int _itr)
{
    if (_itr < BiomeMapResolution * BiomeMapResolution)
    {
        return int2(BiomeMapResolution + (_itr % BiomeMapResolution), _itr / BiomeMapResolution); 
    }
    if (_itr >= BiomeMapResolution * BiomeMapResolution && _itr < BiomeMapResolution * BiomeMapResolution * 4)
    {
        return int2(_itr % BiomeMapResolution * 3 - (BiomeMapResolution * BiomeMapResolution) ,_itr / BiomeMapResolution); 
    }
    else 
    {
        return int2(BiomeMapResolution + (_itr % BiomeMapResolution),_itr / BiomeMapResolution); 
    }
    return int2(-1,-1);   
}
int getBiome(int2 _coord)
{
    if (_coord.x == -1 && _coord.y == -1)
    {
        return -1;
    }
    if (_coord.x >= BiomeMapResolution && _coord.x < BiomeMapResolution * 2 && _coord.y < BiomeMapResolution)
    {
        return biomeMap[(_coord.y * BiomeMapResolution) + (_coord.x + BiomeMapResolution)];
    }
    if (_coord.y >= BiomeMapResolution && _coord.y < BiomeMapResolution * 2)
    {
        return biomeMap[_coord.x + (_coord.y * BiomeMapResolution)];
    }
    if (_coord.y >= BiomeMapResolution * 2 && _coord.x >= BiomeMapResolution && _coord.x < BiomeMapResolution * 2)
    {
        return biomeMap[(_coord.y * BiomeMapResolution) + (_coord.x + BiomeMapResolution)];
    }
    return -1;
}


[numthreads(16,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 normals[] = {float3(0,1,0),float3(-1,0,0),float3(0,0,1),float3(1,0,0),float3(0,-1,0),float3(0,0,-1)};
    //! Set the poles
    float3 NorthPole = float3(0,1,0)  * Radius;
    float3 SouthPole = float3(0,-1,0) * Radius;
    float3 EquatorPole = float3(1,0,0) * Radius;
    float MaximumDistance = abs(length(NorthPole - EquatorPole));
    int titr = 0;
    for (int i = 0; i < 6; i++)
    {
        // Calculate temperature at location
        float3 _normal = normals[i];
        float3 AxisA = float3(_normal.y, _normal.z, _normal.x);
        float3 AxisB = cross(_normal, AxisA);

        float increment = 1.0f / BiomeMapResolution;

        for (int y= 0; y < BiomeMapResolution; y++)
        {
            for (int x = 0; x < BiomeMapResolution; x++)
            {
             
                int itr = x + (y * BiomeMapResolution);
                float2 percent = float2(y, x) / (BiomeMapResolution - 1);
                float3 pointOnUnitCube = _normal + (percent.x - 0.5f) * 2 * AxisA + (percent.y - 0.5f) * 2 * AxisB;
                float3 pointOnUnitSphere = normalize(pointOnUnitCube);
                float3 TerrainVertex = pointOnUnitSphere * mapValues(snoise(pointOnUnitSphere * NoiseScale + Offset), -1.0, 1.0, Radius, Radius + MaximumTerrainHeight);
                
                float3 pointOnGround = pointOnUnitSphere * Radius;
                float DistanceToNorthPole = abs(length(NorthPole - pointOnGround));
                float DistanceToSouthPole = abs(length(SouthPole - pointOnGround));
                float DistanceToPole = 0.0;
                if (DistanceToNorthPole <= MaximumDistance){ DistanceToPole = DistanceToNorthPole; }
                else { DistanceToPole = DistanceToSouthPole; }
                DistanceToPole = mapValues(DistanceToPole, 0.0, MaximumDistance, 0.0, 2 - TemperatureWeight);
                    //! Calculate the Height value
                float HeightFromGround = mapValues(length(TerrainVertex) - Radius, 0.0, MaximumTerrainHeight, 0.0, TemperatureWeight );
                    //! Combine values and map to a 0.0 to 1.0 value
                float TemperatureAtVertex = (DistanceToPole + HeightFromGround) / 2.0;
                temperatureData[titr] = TemperatureAtVertex;
                titr++;
            }
        }
    }

    // Set the biome map to -1 (default value)
    for (int i = 0; i < BiomeMapResolution * BiomeMapResolution * 6; i++) { biomeMap[i] = -1; }
    // Compute Biome from Wind and temperature
    for (int i =0; i < BiomeMapResolution * BiomeMapResolution * 6; i++)
    {
        float temperature = temperatureData[i];
        float moisture = ((1 - temperature) + windData[i]) / 2.0 ;
        int validBiomes[50]; for (int j = 0;  j < 50; j ++) {validBiomes[j] = -1;}
        int numPossibleBiomes = 0;
        for (int biomeItr = 0; biomeItr < numBiomes; biomeItr++)
        {
            if (moisture >= biomes[biomeItr].MinMS && moisture <= biomes[biomeItr].MaxMS) // Check if it is the correct moisture setting
            {
                if (temperature > biomes[biomeItr].MinHS && temperature < biomes[biomeItr].MaxHS) // Check if it is the correct heat setting
                {   
                    validBiomes[numPossibleBiomes] = biomeItr;
                    numPossibleBiomes++;
                }
            }

        }
        if (numPossibleBiomes == 1)
        {
            biomeMap[i] = validBiomes[0];
        }
        else if (numPossibleBiomes > 1)
        {
            int bestBiome = -1;
            int maxNumNeighbours = -1;
            for (int j = 0; j < numPossibleBiomes; j++)
            {
                int numberOfNeigbours = 0;
                int2 coord = getXYCoord(i);
                if (getBiome(int2(coord.x + 1, coord.y    )) == validBiomes[j] || getBiome(int2(coord.x + 1, coord.y    )) == -1) { maxNumNeighbours++; }
                if (getBiome(int2(coord.x + 1, coord.y - 1)) == validBiomes[j] || getBiome(int2(coord.x + 1, coord.y - 1)) == -1) { maxNumNeighbours++; }
                if (getBiome(int2(coord.x    , coord.y - 1)) == validBiomes[j] || getBiome(int2(coord.x    , coord.y - 1)) == -1) { maxNumNeighbours++; }
                if (getBiome(int2(coord.x - 1, coord.y - 1)) == validBiomes[j] || getBiome(int2(coord.x - 1, coord.y - 1)) == -1) { maxNumNeighbours++; }
                if (getBiome(int2(coord.x - 1, coord.y    )) == validBiomes[j] || getBiome(int2(coord.x - 1, coord.y    )) == -1) { maxNumNeighbours++; }
                if (getBiome(int2(coord.x - 1, coord.y + 1)) == validBiomes[j] || getBiome(int2(coord.x - 1, coord.y + 1)) == -1) { maxNumNeighbours++; }
                if (getBiome(int2(coord.x    , coord.y + 1)) == validBiomes[j] || getBiome(int2(coord.x    , coord.y + 1)) == -1) { maxNumNeighbours++; }
                if (getBiome(int2(coord.x + 1, coord.y + 1)) == validBiomes[j] || getBiome(int2(coord.x + 1, coord.y + 1)) == -1) { maxNumNeighbours++; }
                if (numberOfNeigbours > maxNumNeighbours) { maxNumNeighbours = numberOfNeigbours; bestBiome = validBiomes[j]; } 
            }
            biomeMap[i] = bestBiome;
        }
        else
        {
            biomeMap[i] = -1;
        }
    }


}
