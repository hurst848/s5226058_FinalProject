#pragma kernel CSMain

// https://gist.github.com/fadookie/25adf86ae7e2753d717c
#include "noiseSimplex.cginc"

RWTexture2D<float4> Result;

RWStructuredBuffer<float> temperatureData;
RWStructuredBuffer<float2> windData;

float TemperatureWeight;
int BiomeMapResolution;
float Radius;
float NoiseScale;
float Offset;
float MaximumTerrainHeight;

float mapValues(float _value, float _fromA, float _ToA, float _fromB, float _ToB)
{
    return (_value - _fromA) / (_ToA - _fromA) * (_ToB - _fromB) + _fromB;
}














[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float3 normals[] = {float3(0,1,0),float3(-1,0,0),float3(0,0,1),float3(1,0,0),float3(0,-1,0),float3(0,0,-1)};
    //! Set the poles
    float3 NorthPole = float3(0,1,0)  * Radius;
    float3 SouthPole = float3(0,-1,0) * Radius;
    float3 EquatorPole = float3(1,0,0) * Radius;
    float MaximumDistance = 0.0;
    MaximumDistance = abs(length(NorthPole - EquatorPole));
    int titr = 0;
    for (int i = 0; i < 6; i++)
    {
        // Calculate temperature at location
        float3 _normal = normals[i];
        float3 AxisA = float3(_normal.y, _normal.z, _normal.x);
        float3 AxisB = cross(_normal, AxisA);

        float increment = 1.0f / BiomeMapResolution;

        for (int y= 0; y < BiomeMapResolution; y++)
        {
            for (int x = 0; x < BiomeMapResolution; x++)
            {
             
                int itr = x + (y * BiomeMapResolution);
                float2 percent = float2(y, x) / (BiomeMapResolution - 1);
                float3 pointOnUnitCube = _normal + (percent.x - 0.5f) * 2 * AxisA + (percent.y - 0.5f) * 2 * AxisB;
                float3 pointOnUnitSphere = normalize(pointOnUnitCube);
                float3 TerrainVertex = pointOnUnitSphere * mapValues(snoise(pointOnUnitSphere * NoiseScale + Offset), 0.0, 1.0, Radius, Radius + MaximumTerrainHeight);
                
                float3 pointOnGround = pointOnUnitSphere * Radius;
                float DistanceToNorthPole = abs(length(NorthPole - pointOnGround));
                float DistanceToSouthPole = abs(length(SouthPole - pointOnGround));
                float DistanceToPole = 0.0;
                if (DistanceToNorthPole <= MaximumDistance){ DistanceToPole = DistanceToNorthPole; }
                else { DistanceToPole = DistanceToSouthPole; }
                DistanceToPole = mapValues(DistanceToPole, 0.0, MaximumDistance, 0.0, 2 - TemperatureWeight);
                    //! Calculate the Height value
                float HeightFromGround = mapValues(length(TerrainVertex) - Radius, 0.0, MaximumTerrainHeight, 0.0, 2 - (2 - TemperatureWeight) );
                    //! Combine values and map to a 0.0 to 1.0 value
                float TemperatureAtVertex = mapValues(DistanceToPole + HeightFromGround, 0.0, 2.0, 0.0, 1.0);
                temperatureData[titr] = TemperatureAtVertex;
                titr++;
            }
        }
    }

    // Generate Wind


}
